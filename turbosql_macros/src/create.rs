use super::{MigrationsToml, Table};
use proc_macro_error::abort_call_site;
use quote::quote;
use rusqlite::params;
use serde::Serialize;
use std::fs;

const MIGRATIONS_FILENAME: &str = "migrations.toml";

/// CREATE TABLE
pub(super) fn create(table: &Table) -> proc_macro2::TokenStream {
 // create the migrations

 let sql = makesql_create(&table);

 rusqlite::Connection::open_in_memory().unwrap().execute(&sql, params![]).unwrap_or_else(|e| {
  abort_call_site!("Error validating auto-generated CREATE TABLE statement:\n{}\n{:#?}", sql, e)
 });

 let target_migrations = make_migrations(&table);

 // read in the existing migrations from toml

 let lockfile = std::fs::File::create(std::env::temp_dir().join("migrations.toml.lock")).unwrap();
 fs2::FileExt::lock_exclusive(&lockfile).unwrap();

 let migrations_toml_path = std::env::current_dir().unwrap().join(MIGRATIONS_FILENAME);
 let migrations_toml_path_lossy = migrations_toml_path.to_string_lossy();

 let source_migrations_toml = match migrations_toml_path.exists() {
  true => {
   let toml_str = fs::read_to_string(&migrations_toml_path)
    .unwrap_or_else(|e| abort_call_site!("Unable to read {}: {:?}", migrations_toml_path_lossy, e));

   let toml_decoded: MigrationsToml = toml::from_str(&toml_str).unwrap_or_else(|e| {
    abort_call_site!("Unable to decode toml in {}: {:?}", migrations_toml_path_lossy, e)
   });

   toml_decoded
  }
  false => MigrationsToml { ..Default::default() },
 };

 // add any migrations that aren't already present

 let mut output_migrations: Vec<String> =
  source_migrations_toml.migrations_append_only.clone().unwrap_or_default();

 target_migrations.iter().for_each(|m1| {
  if source_migrations_toml
   .migrations_append_only
   .clone()
   .unwrap_or_default()
   .iter()
   .find(|m2| m2 == &m1)
   .is_none()
  {
   output_migrations.push(m1.clone());
  }
 });

 // save to toml

 let mut toml_str = String::new();
 let mut serializer = toml::Serializer::pretty(&mut toml_str);
 serializer.pretty_array_indent(2);

 MigrationsToml {
  target_schema_autogenerated: Some(super::migrations_to_schema(&output_migrations).unwrap()),
  migrations_append_only: Some(output_migrations),
 }
 .serialize(&mut serializer)
 .unwrap_or_else(|e| abort_call_site!("Unable to serialize migrations toml: {:?}", e));

 let migrations_file_str = format!(
  r"# This file is auto-generated by Turbosql.
# It is used to create and apply automatic schema migrations.
# It should be checked into source control.
# Modifying it by hand may be dangerous; see the docs.

 {}",
  &toml_str
 );

 fs::write(&migrations_toml_path, migrations_file_str)
  .unwrap_or_else(|e| abort_call_site!("Unable to write {}: {:?}", migrations_toml_path_lossy, e));

 // let table_name = table.name.clone();

 // quote! {
 //  fn __turbosql_ensure_table_created() {
 //   static ONCE: ::turbosql::Lazy<()> = ::turbosql::Lazy::new(|| {
 //    ::turbosql::__ensure_table_created(#table_name, #sql, vec![#(#target_migrations),*]);
 //   });

 //   ::turbosql::Lazy::force(&ONCE);
 //  }
 // }
 quote!()
}

fn makesql_create(table: &Table) -> String {
 let mut sql = format!("CREATE TABLE {} (\n", table.name);

 sql += table
  .columns
  .iter()
  .map(|c| format!(" {} {}", c.name, c.sqltype))
  .collect::<Vec<_>>()
  .join(",\n")
  .as_str();

 sql += "\n)";

 sql
}

// TODO make sure this works if user puts rowid member someplace other than first
// (or enforce first position)

fn make_migrations(table: &Table) -> Vec<String> {
 let mut vec = vec![format!("CREATE TABLE {} (rowid INTEGER PRIMARY KEY)", table.name)];

 let mut alters = table
  .columns
  .iter()
  .filter_map(|c| match (c.name.as_str(), c.sqltype) {
   ("rowid", "INTEGER PRIMARY KEY") => None,
   _ => Some(format!("ALTER TABLE {} ADD COLUMN {} {}", table.name, c.name, c.sqltype)),
  })
  .collect::<Vec<_>>();

 vec.append(&mut alters);

 vec
}
